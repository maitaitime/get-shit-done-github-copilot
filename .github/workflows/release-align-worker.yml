name: Release Align Worker
on:
  schedule:
    # check for new upstream releases hourly
    - cron: "13 * * * *"
  workflow_dispatch:
    inputs:
      upstream_tag:
        description: "Optional: align to this upstream release tag (blank = latest)"
        required: false
        default: ""

concurrency:
  group: release-align-worker
  cancel-in-progress: false

permissions:
  contents: write
  actions: write

env:
  UPSTREAM_REPO: gsd-build/get-shit-done
  BASE_BRANCH: main
  EXEMPTIONS_FILE: scripts/guard-exemptions.txt
  PROMPTS_DIR: .github/prompts
  REPAIR_WORKFLOW: upstream-sync-repair-agent.yml
  MIRROR_WORKFLOW: release-mirror-worker.yml

jobs:
  align:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (fork repo)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: false

      - name: Configure git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Resolve upstream release tag
        id: tag
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          IN_TAG="${{ inputs.upstream_tag }}"
          if [ -n "$IN_TAG" ]; then
            UP_TAG="$IN_TAG"
          else
            UP_TAG=$(gh api "repos/${UPSTREAM_REPO}/releases/latest" --jq '.tag_name // empty' 2>/dev/null || true)
          fi

          if [ -z "$UP_TAG" ]; then
            echo "No upstream release tag found; exiting."
            echo "upstream_tag=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "upstream_tag=$UP_TAG" >> "$GITHUB_OUTPUT"
          echo "Upstream release tag: $UP_TAG"

      - name: Exit if no upstream tag resolved
        if: steps.tag.outputs.upstream_tag == ''
        run: echo "Nothing to do."

      - name: Skip if already mirrored
        if: steps.tag.outputs.upstream_tag != ''
        id: mirrored
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          UP_TAG="${{ steps.tag.outputs.upstream_tag }}"
          if gh release list --repo "$GITHUB_REPOSITORY" --limit 200 --json tagName --jq '.[].tagName' | grep -q "upstream-${UP_TAG}"; then
            echo "needs_mirror=false" >> "$GITHUB_OUTPUT"
            echo "Already mirrored upstream tag $UP_TAG."
          else
            echo "needs_mirror=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Stop if already mirrored
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'false'
        run: echo "Release already mirrored."

      - name: Add upstream remote + fetch upstream tag (namespaced) + fetch fork base
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true'
        run: |
          set -euo pipefail
          UP_TAG="${{ steps.tag.outputs.upstream_tag }}"

          git remote add upstream "https://github.com/${UPSTREAM_REPO}.git" || true
          git remote set-url --push upstream DISABLED || true

          # fork base
          git fetch origin "${BASE_BRANCH}" --prune --no-tags

          # Fetch only the needed upstream tag into a namespaced tag; prevent tag auto-follow spam
          git fetch upstream --no-tags "refs/tags/${UP_TAG}:refs/tags/upstream/${UP_TAG}" --prune

      - name: Create release-align branch at upstream tag (NO PUSH YET)
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true'
        run: |
          set -euo pipefail
          UP_TAG="${{ steps.tag.outputs.upstream_tag }}"
          SAFE_TAG=$(echo "$UP_TAG" | sed 's/[^A-Za-z0-9._-]/-/g')
          BR="automated/release-align-${SAFE_TAG}"

          git rev-parse "refs/tags/upstream/${UP_TAG}" >/dev/null
          git checkout -B "$BR" "refs/tags/upstream/${UP_TAG}"
          echo "BRANCH=$BR" >> "$GITHUB_ENV"

      # ---- Critical: enforce fork-owned workflows BEFORE any push ----
      - name: Force fork-owned workflows (pre-push safety)
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true'
        run: |
          set -euo pipefail
          BASE="${BASE_BRANCH}"

          # If fork base has workflows, restore them exactly; otherwise delete workflows entirely.
          if git cat-file -e "origin/${BASE}:.github/workflows" 2>/dev/null; then
            echo "Restoring .github/workflows from origin/${BASE}"
            git checkout "origin/${BASE}" -- .github/workflows
            git add -A .github/workflows
          else
            echo "Fork base has no .github/workflows; removing any workflows from upstream snapshot"
            rm -rf .github/workflows || true
            git add -A .github/workflows || true
          fi

          if git diff --cached --quiet; then
            echo "No workflow changes staged."
          else
            git commit -m "chore: enforce fork-owned workflows (release align)" || true
          fi

      - name: Materialize exemption script (from fork base if present; else fallback)
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true'
        run: |
          set -euo pipefail
          BASE="${BASE_BRANCH}"

          if git cat-file -e "origin/${BASE}:scripts/apply-guard-exemptions.sh" 2>/dev/null; then
            echo "Using scripts/apply-guard-exemptions.sh from origin/${BASE}"
            git show "origin/${BASE}:scripts/apply-guard-exemptions.sh" > /tmp/apply-guard-exemptions.sh
          else
            echo "::warning::apply-guard-exemptions.sh not found on origin/${BASE}. Using embedded fallback."
            cat > /tmp/apply-guard-exemptions.sh <<'EOF'
          #!/usr/bin/env bash
          set -euo pipefail

          BASE_BRANCH="${BASE_BRANCH:-main}"
          EXEMPTIONS_FILE="${EXEMPTIONS_FILE:-scripts/guard-exemptions.txt}"

          if [[ ! -f "$EXEMPTIONS_FILE" ]]; then
            echo "No exemptions file at $EXEMPTIONS_FILE; nothing to apply."
            exit 0
          fi

          git fetch origin "${BASE_BRANCH}" --prune --no-tags >/dev/null 2>&1 || true
          mapfile -t RAW_LINES < <(grep -vE '^\s*($|#)' "$EXEMPTIONS_FILE" || true)

          is_glob_pattern() {
            local pat="$1"
            [[ "$pat" == *"/**"* || "$pat" == *"*"* || "$pat" == *"?"* || "$pat" == *"["*"]"* ]]
          }

          expand_pattern() {
            local pat="$1"

            if [[ "$pat" == *"/**"* ]]; then
              local prefix="${pat%%/***}"
              prefix="${prefix%/}"
              git ls-files -- "$prefix" || true
              return 0
            fi

            if [[ "$pat" == *"*"* || "$pat" == *"?"* || "$pat" == *"["*"]"* ]]; then
              git ls-files -- "$pat" || true
              return 0
            fi

            echo "$pat"
          }

          applied=false

          for raw in "${RAW_LINES[@]}"; do
            pat="$(echo "$raw" | sed 's/#.*//' | xargs)"
            [[ -z "$pat" ]] && continue

            glob_mode=false
            if is_glob_pattern "$pat"; then
              glob_mode=true
            fi

            while IFS= read -r f; do
              [[ -z "$f" ]] && continue

              if git cat-file -e "origin/${BASE_BRANCH}:$f" 2>/dev/null; then
                echo "Exempt (base wins): $f"
                git checkout "origin/${BASE_BRANCH}" -- "$f"
                git add "$f" >/dev/null 2>&1 || true
                applied=true
              else
                if [[ "$glob_mode" == "true" ]]; then
                  echo "Exempt glob (base missing -> remove): $f"
                  git rm -f --ignore-unmatch "$f" >/dev/null 2>&1 || true
                  rm -f "$f" >/dev/null 2>&1 || true
                  git add -A -- "$f" >/dev/null 2>&1 || true
                  applied=true
                else
                  echo "::warning::Exempt literal '$f' not found in origin/${BASE_BRANCH}; skipping (no delete)."
                fi
              fi
            done < <(expand_pattern "$pat")
          done

          if [[ "$applied" == "true" ]]; then
            echo "Guard exemptions applied."
          else
            echo "No exemptions matched any tracked files."
          fi
          EOF
          fi

          chmod +x /tmp/apply-guard-exemptions.sh

      - name: Apply guard exemptions (fork-owned; globs+recursive; lenient)
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true'
        run: |
          set -euo pipefail
          export BASE_BRANCH="${BASE_BRANCH}"
          export EXEMPTIONS_FILE="${EXEMPTIONS_FILE}"
          bash /tmp/apply-guard-exemptions.sh

          if git diff --cached --quiet; then
            echo "No exemptions staged."
          else
            git commit -m "chore: enforce fork-owned files (release align)" || true
          fi

      - name: Push safe baseline branch (after workflows + exemptions)
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true'
        run: |
          set -euo pipefail
          git push -u origin "${BRANCH}" --force-with-lease

      - name: Setup Node
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true'
        run: npm ci

      - name: Regenerate prompts for release snapshot + verify
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true'
        id: verify
        run: |
          set -euo pipefail
          rm -rf "${PROMPTS_DIR:?}/"* || true
          node scripts/generate-prompts.mjs 2>&1 | tee /tmp/generate.log
          set +e
          node scripts/verify-prompts.mjs 2>&1 | tee /tmp/verify.log
          VERIFY_EXIT=${PIPESTATUS[0]}
          set -e
          if [ "$VERIFY_EXIT" -eq 0 ]; then
            echo "verify_ok=true" >> "$GITHUB_OUTPUT"
            echo "Release snapshot prompt verification passed."
          else
            echo "verify_ok=false" >> "$GITHUB_OUTPUT"
            echo "Release snapshot prompt verification failed (exit $VERIFY_EXIT)."
          fi

      - name: Upload prompt logs on release verify failure
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true' && steps.verify.outputs.verify_ok == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: release-align-verify-logs
          path: |
            /tmp/generate.log
            /tmp/verify.log

      - name: Dispatch repair agent for release verify failure
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true' && steps.verify.outputs.verify_ok == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          gh workflow run "${REPAIR_WORKFLOW}" \
            --repo "$GITHUB_REPOSITORY" \
            -f branch="${BRANCH}" \
            -f reason="release_verify_failed" \
            -f upstream_repo="${UPSTREAM_REPO}" \
            -f upstream_tag="${{ steps.tag.outputs.upstream_tag }}" \
            -f base_branch="${BASE_BRANCH}"
          echo "Repair agent dispatched. Worker exiting."
          exit 0

      - name: Commit release-aligned prompts
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true'
        run: |
          set -euo pipefail
          git add -A "${PROMPTS_DIR}" || true
          if git diff --cached --quiet; then
            echo "No prompt changes to commit (unexpected for release-align)."
          else
            git commit -m "chore: release-align prompts for ${{ steps.tag.outputs.upstream_tag }}" || true
          fi

      - name: Push release-align branch (with prompts)
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true'
        run: |
          set -euo pipefail
          git push -u origin "${BRANCH}" --force-with-lease

      - name: Dispatch release-mirror-worker (creates fork tag + release w/ upstream notes)
        if: steps.tag.outputs.upstream_tag != '' && steps.mirrored.outputs.needs_mirror == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          gh workflow run "${MIRROR_WORKFLOW}" \
            --repo "$GITHUB_REPOSITORY" \
            -f upstream_repo="${UPSTREAM_REPO}" \
            -f upstream_tag="${{ steps.tag.outputs.upstream_tag }}" \
            -f target_ref="${BRANCH}" \
            -f force="false"
          echo "Dispatched release-mirror-worker. It will push the fork tag; release.yml will build/upload the zip on tag push."