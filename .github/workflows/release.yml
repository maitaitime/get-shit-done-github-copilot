name: Publish Release
on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to package (e.g. v0.0.7-upstream-v1.21.1)"
        required: true
        type: string

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write

env:
  EXPECTED_REPO: maitaitime/get-shit-done-github-copilot

jobs:
  publish-release:
    runs-on: ubuntu-latest
    steps:
      - name: Assert fork context
        run: |
          if [ "$GITHUB_REPOSITORY" != "${{ env.EXPECTED_REPO }}" ]; then
            echo "ERROR: This workflow is running on '$GITHUB_REPOSITORY' but is only intended to run on '${{ env.EXPECTED_REPO }}'."
            exit 1
          fi

      - name: Resolve tag to build
        id: tag
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG="${{ inputs.tag }}"
          else
            TAG="${{ github.ref_name }}"
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "Packaging tag: $TAG"

      - name: Checkout tag
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: refs/tags/${{ steps.tag.outputs.tag }}

      - name: Build zip artifact
        run: |
          # --- Create staging directory structure ---
          mkdir -p staging/.github/prompts
          mkdir -p staging/.github/instructions
          mkdir -p staging/.claude/commands/gsd
          mkdir -p staging/.claude/get-shit-done
          mkdir -p staging/.claude/agents
          mkdir -p staging/.claude/hooks
          mkdir -p staging/gsd-copilot-installer

          # --- Copilot layer: .github/ files ---
          cp -r .github/prompts/. staging/.github/prompts/

          find .github/instructions -maxdepth 1 \( -name "gsd-*.instructions.md" -o -name "gsd.*.md" \) \
            -exec cp {} staging/.github/instructions/ \; 2>/dev/null || true

          # --- Upstream runtime: .claude/ ---
          cp -r commands/gsd/. staging/.claude/commands/gsd/
          cp -r get-shit-done/. staging/.claude/get-shit-done/
          cp -r agents/. staging/.claude/agents/

          find hooks -maxdepth 1 -name "*.js" -exec cp {} staging/.claude/hooks/ \; 2>/dev/null || true

          echo '{"type":"commonjs"}' > staging/.claude/package.json

          cp gsd-copilot-installer/gsd-copilot-install.ps1 staging/gsd-copilot-installer/gsd-copilot-install.ps1
          cp gsd-copilot-installer/README.md staging/gsd-copilot-installer/README.md

          find staging/.claude -name "*.md" -exec sed -i 's#~/.claude/#./.claude/#g' {} \;

          TAG="${{ steps.tag.outputs.tag }}"
          cd staging && zip -r "../gsd-copilot-${TAG}.zip" .

      - name: Validate zip contents
        run: |
          echo "Validating zip contents..."
          TAG="${{ steps.tag.outputs.tag }}"
          ZIP="gsd-copilot-${TAG}.zip"
          fail=0
          check_path() {
            local label="$1"
            local pattern="$2"
            if unzip -l "$ZIP" | grep -q "$pattern"; then
              echo " ✓ $label"
            else
              echo " ✗ MISSING: $label ($pattern)"
              fail=1
            fi
          }
          check_path ".github/prompts/" ".github/prompts/"
          check_path ".claude/commands/gsd/" ".claude/commands/gsd/"
          check_path ".claude/get-shit-done/workflows/" ".claude/get-shit-done/workflows/"
          check_path ".claude/agents/" ".claude/agents/"
          check_path ".claude/hooks/" ".claude/hooks/"
          check_path ".claude/get-shit-done/bin/gsd-tools.cjs" ".claude/get-shit-done/bin/gsd-tools.cjs"
          check_path ".claude/package.json" ".claude/package.json"
          check_path "at least one .prompt.md" "\.prompt\.md"
          if [ "$fail" -eq 1 ]; then
            echo ""
            echo "Release blocked: zip is missing required paths. See errors above."
            exit 1
          fi
          echo "All zip contents validated."

      - name: Upload asset to release (create release only if missing)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ steps.tag.outputs.tag }}"
          ZIP="./gsd-copilot-${TAG}.zip"

          # Ensure release exists (mirror worker usually creates it)
          if ! gh release view "$TAG" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
            echo "::warning::Release $TAG does not exist yet; creating it."
            gh release create "$TAG" "$ZIP" \
              --repo "$GITHUB_REPOSITORY" \
              --title "GSD Copilot $TAG" \
              --generate-notes
            exit 0
          fi

          echo "Uploading asset to existing release $TAG"
          gh release upload "$TAG" "$ZIP" --repo "$GITHUB_REPOSITORY" --clobber