name: Publish Release
on:
  push:
    tags:
      - 'v*'

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write

env:
  EXPECTED_REPO: darrylwisner/get-shit-done-github-copilot

jobs:
  publish-release:
    runs-on: ubuntu-latest
    steps:
      # SAFETY: Always run this assertion first. Add --repo "$GITHUB_REPOSITORY" to any new gh command you add here.
      - name: Assert fork context
        run: |
          if [ "$GITHUB_REPOSITORY" != "${{ env.EXPECTED_REPO }}" ]; then
            echo "ERROR: This workflow is running on '$GITHUB_REPOSITORY' but is only intended to run on '${{ env.EXPECTED_REPO }}'."
            echo "Refusing to proceed — this prevents accidental writes to the wrong repository."
            exit 1
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Build zip artifact
        run: |
          # --- Create staging directory structure ---
          mkdir -p staging/.github/prompts
          mkdir -p staging/.github/instructions
          mkdir -p staging/.claude/commands/gsd
          mkdir -p staging/.claude/get-shit-done
          mkdir -p staging/.claude/agents
          mkdir -p staging/.claude/hooks
          mkdir -p staging/gsd-copilot-installer

          # --- Copilot layer: .github/ files ---
          # Prompts
          cp -r .github/prompts/. staging/.github/prompts/

          # GSD-prefixed instruction files only (true: dir may be empty or missing)
          find .github/instructions -maxdepth 1 \( -name "gsd-*.instructions.md" -o -name "gsd.*.md" \) \
            -exec cp {} staging/.github/instructions/ \; 2>/dev/null || true

          # NOTE: .github/agents/ is intentionally omitted — it is empty by design.

          # --- Upstream runtime: .claude/ ---
          # Commands
          cp -r commands/gsd/. staging/.claude/commands/gsd/

          # Get-shit-done runtime tree
          cp -r get-shit-done/. staging/.claude/get-shit-done/

          # Agents
          cp -r agents/. staging/.claude/agents/

          # Hooks (.js files only — true: tolerates empty or missing dir)
          find hooks -maxdepth 1 -name "*.js" -exec cp {} staging/.claude/hooks/ \; 2>/dev/null || true

          # --- CommonJS mode marker ---
          echo '{"type":"commonjs"}' > staging/.claude/package.json

          # --- Installer files ---
          cp gsd-copilot-installer/gsd-copilot-install.ps1 staging/gsd-copilot-installer/gsd-copilot-install.ps1
          cp gsd-copilot-installer/README.md staging/gsd-copilot-installer/README.md

          # --- Path replacement: rewrite ~/.claude/ → ./.claude/ in all .md files ---
          find staging/.claude -name "*.md" -exec sed -i 's#~/.claude/#./.claude/#g' {} \;

          # --- Zip flat-at-root (paths inside zip start at .github/, .claude/, etc.) ---
          cd staging && zip -r ../gsd-copilot-${{ github.ref_name }}.zip .

      - name: Validate zip contents
        run: |
          echo "Validating zip contents..."
          ZIP="gsd-copilot-${{ github.ref_name }}.zip"
          fail=0
          check_path() {
            local label="$1"
            local pattern="$2"
            if unzip -l "$ZIP" | grep -q "$pattern"; then
              echo " ✓ $label"
            else
              echo " ✗ MISSING: $label ($pattern)"
              fail=1
            fi
          }
          check_path ".github/prompts/" ".github/prompts/"
          check_path ".claude/commands/gsd/" ".claude/commands/gsd/"
          check_path ".claude/get-shit-done/workflows/" ".claude/get-shit-done/workflows/"
          check_path ".claude/agents/" ".claude/agents/"
          check_path ".claude/hooks/" ".claude/hooks/"
          check_path ".claude/get-shit-done/bin/gsd-tools.cjs" ".claude/get-shit-done/bin/gsd-tools.cjs"
          check_path ".claude/package.json" ".claude/package.json"
          check_path "at least one .prompt.md" "\.prompt\.md"
          if [ "$fail" -eq 1 ]; then
            echo ""
            echo "Release blocked: zip is missing required paths. See errors above."
            exit 1
          fi
          echo "All zip contents validated."

      - name: Create GitHub Release (if missing) and upload asset
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ github.ref_name }}"
          ZIP="./gsd-copilot-${{ github.ref_name }}.zip"

          # Avoid race with release-mirror-worker: wait briefly for the release to exist.
          for i in $(seq 1 10); do
            if gh release view "$TAG" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
              echo "Release $TAG already exists (attempt $i)."
              break
            fi
            echo "Release $TAG not found yet (attempt $i). Waiting..."
            sleep 3
          done

          if gh release view "$TAG" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
            echo "Uploading asset to existing release $TAG"
            gh release upload "$TAG" "$ZIP" --repo "$GITHUB_REPOSITORY" --clobber
          else
            echo "Creating release $TAG and uploading asset"
            gh release create "$TAG" "$ZIP" \
              --repo "$GITHUB_REPOSITORY" \
              --title "GSD Copilot $TAG" \
              --generate-notes
          fi
